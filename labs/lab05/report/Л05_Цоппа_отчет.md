
---
## Front matter
title: "Отчёт по лабораторной работе 4"
subtitle: "Дисциплина: архитектура компьютера"
author: "Цоппа Ева Эдуардовна"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

**1 Цель работы**  

Цель данной лабораторной работы – освоить процедуры компиляции и сборки программ, написанных на ассемблере NASM. 

**2 Задание** 

1. Создание программы Hello world! 
1. Работа с транслятором NASM. 
1. Работа с расширенным синтаксисом командной строки NASM. 
1. Работа с компоновщиком LD. 
1. Запуск исполняемого файла. 
1. Выполнение заданий для самостоятельной работы. 

**3 Теоретическое введение** 

Основными функциональными элементами любой ЭВМ являются центральный процессор,  память  и  периферийные  устройства.  Взаимодействие  этих  устройств осуществляется через общую шину, к которой они подключены. Физически шина представляет  собой  большое  количество  проводников,  соединяющих  устройства друг  с  другом.  В  современных  компьютерах  проводники  выполнены  в  виде электропроводящих дорожек на материнской плате. Основной задачей процессора является  обработка  информации,  а  также  организация  координации  всех  узлов компьютера. В состав  центрального процессора входят следующие устройства:  - арифметико-логическое  устройство  (АЛУ)  —  выполняет  логические  и арифметические действия, необходимые для обработки информации, хранящейся в памяти; - устройство управления (УУ) — обеспечивает управление и контроль всех устройств компьютера; - регистры — сверхбыстрая оперативная память небольшого объёма, входящая в состав процессора, для временного хранения промежуточных результатов  выполнения  инструкций;  регистры  процессора  делятся  на  два  типа: регистры  общего  назначения  и  специальные  регистры.  Для  того,  чтобы  писать программы  на  ассемблере,  необходимо  знать,  какие  регистры  процессора существуют  и  как  их  можно  использовать.  Большинство  команд  в  программах написанных  на  ассемблере  используют  регистры  в  каче-  стве  операндов. Практически все команды представляют собой преобразование данных хранящихся в регистрах процессора, это например пересылка данных между регистрами или между регистрами и памятью, преобразование (арифметические или логические операции) данных хранящихся в регистрах. Доступ к регистрам осуществляется не по  адресам,  как  к  основной  памяти,  а  по  именам.  Каждый  регистр  процессора архитектуры  x86  имеет  свое  название,  состоящее  из  2  или  3  букв  латинского алфавита.  В  качестве  примера  приведем  названия  основных  регистров  общего назначения  (именно  эти  регистры  чаще  всего  используются  при  написании программ): - RAX, RCX, RDX, RBX, RSI, RDI — 64-битные - EAX, ECX, EDX, EBX, ESI, EDI — 32-битные - AX, CX, DX, BX, SI, DI — 16-битные - AH, AL, CH, CL, DH, DL, BH, BL — 8- битные 

Другим важным узлом ЭВМ является оперативное запоминающее устройство (ОЗУ). ОЗУ — это быстродействующее энергозависимое запоминающее устройство, которое напрямую взаимодействует с узлами процессора,  предназначенное для хранения программ и данных, с которыми процессор непосредственно работает в текущий  момент.  ОЗУ  состоит  из  одинаковых  пронумерованных  ячеек  памяти. Номер  ячейки  памяти  —  это  адрес  хранящихся  в  ней  данных.  Периферийные устройства в составе ЭВМ: - устройства внешней памяти, которые предназначены для  долговременного  хранения  больших  объёмов  данных.  -  устройства  ввода- вывода, которые обеспечивают взаимодействие ЦП с внешней средой. 

В  основе  вычислительного  процесса  ЭВМ  лежит  принцип  программного управления.  Это  означает,  что  компьютер  решает  поставленную  задачу  как последовательность действий, записанных в виде программы. 

Коды команд представляют собой многоразрядные двоичные комбинации из 0 и 1. В коде машинной команды можно выделить две части: операционную и адресную. В операционной части хранится код команды, которую необходимо выполнить. В адресной  части  хранятся  данные  или  адреса  данных,  которые  участвуют  в выполнении  данной  операции.  При  выполнении  каждой  команды  процессор выполняет  определённую  последовательность  стандартных  действий,  которая называется  командным  циклом  процессора.  Он  заключается  в  следующем:  1. формирование адреса в памяти очередной команды; 2. считывание кода команды из  памяти  и  её  дешифрация; 3.  выполнение  команды;  4.  переход  к следующей команде. 

Язык  ассемблера  (assembly  language,  сокращённо  asm)  —  машинно- ориентированный язык низкого уровня. NASM — это открытый проект ассемблера, версии  которого  доступны  под  различные  операционные  системы  и  который позволяет получать объектные файлы для этих систем. В NASM используется Intel- синтаксис и поддерживаются инструкции x86-64. 

**4 Выполнение лабораторной работы** 

1. **Создание программы Hello world!**

С помощью утилиты cd перемещаюсь в каталог, в котором буду работать (рис. 

4\.1). 

![Screenshot_291](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/23c2c0d3-80fb-4d51-82a9-e1c3959bc05e)


Рис. 4.1 Перемещение между директориями 

Создаю в текущем каталоге пустой текстовый файл hello.asm с помощью утилиты touch (рис. 4.2). 


![Screenshot_292](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/da4e6a63-5a7b-4fb0-bffb-c742865a7857)

Рис. 4.2 Создание пустого файла 

Открываю созданный файл в текстовом редакторе mousepad (рис. 4.3). 

![Screenshot_293](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/b2995b54-3be9-4a75-a081-bd5142475f9b)


Рис. 4.3 Открытие файла в текстовом редакторе 

Заполняю файл, вставляя в него программу для вывода “Hello world!” (рис. 

4\.4). 

![Screenshot_294](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/1dab3981-aa45-46c4-a636-ea1004ec011a)


Рис. 4.4 Заполнение файла 

2. **Работа с транслятором NASM** 

Превращаю текст программы для вывода “Hello  world!” в объектный код с помощью  транслятора  NASM,  используя  команду  nasm  -f  elf  hello.asm,  ключ  -f указывает транслятору nasm, что требуется создать бинарный файл в формате ELF (рис. 4.5). Далее проверяю правильность выполнения команды с помощью утилиты ls: действительно, создан файл “hello.o”. 

![Screenshot_321](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/d51e23e9-082b-437b-acb1-2db74f81cf8e)


Рис. 4.5 Компиляция текста программы 

3. **Работа с расширенным синтаксисом командной строки NASM** 

Ввожу команду, которая скомпилирует файл hello.asm в файл obj.o, при этом в файл будут включены символы для отладки (ключ -g), также с помощью ключа -l будет создан файл листинга list.lst (рис. 4.6). Далее проверяю с помощью утилиты ls правильность выполнения команды. 

![Screenshot_322](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/6c2a8a74-7aa6-41ab-bc74-b3a762c16be5)


Рис. 4.6 Компиляция текста программы 

4. **Работа с компоновщиком LD** 

Передаю  объектный  файл  hello.o  на  обработку  компоновщику  LD,  чтобы получить  исполняемый  файл  hello  (рис.  4.7).  Ключ  -о  задает  имя  создаваемого исполняемого  файла.  Далее  проверяю  с  помощью  утилиты  ls  правильность выполнения команды. 

![Screenshot_323](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/150782e5-aad5-44b3-9dd0-789868807d58)


Рис. 4.7 Передача объектного файла на обработку компоновщику 

Выполняю следующую команду (рис. 4.8). Исполняемый файл будет иметь имя main, т.к. после ключа -о было задано значение main. Объектный файл, из которого собран этот исполняемый файл, имеет имя obj.o 

![Screenshot_324](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/5bc7ecf8-fc72-4feb-bb3f-03d7059c49f3)


Рис. 4.8 Передача объектного файла на обработку компоновщику 

5. **Запуск исполняемого файла** 

Запускаю на выполнение созданный исполняемый файл hello (рис. 4.9). 

![Screenshot_325](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/e3c9be6d-6238-471c-880d-377d5c8a8e8d)


Рис. 4.9 Запуск исполняемого файла 

6. **Выполнение заданий для самостоятельной работы** 

С помощью утилиты cp создаю в текущем каталоге копию файла hello.asm с именем lab4.asm (рис. 4.10). 

![Screenshot_326](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/0a0c788d-f7a5-414e-b8ad-2f5f32b92f5b)


Рис. 4.10 Создание копии файла 

С помощью текстового редактора mousepad открываю файл lab4.asm и вношу изменения в программу так, чтобы она выводила мои имя и фамилию. (рис. 4.11). 

![Screenshot_327](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/666eeefc-de9a-4b48-89be-97ebcb28ab70)


Рис. 4.11 Изменение программы 

Компилирую  текст  программы  в  объектный  файл  (рис.  12).  Проверяю  с помощью утилиты ls, что файл lab4.o создан. 

![Screenshot_328](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/cfdb73ab-7098-40d4-908f-f084451889d7)


Рис. 4.12 Компиляция текста программы 

Передаю  объектный  файл  lab4.o  на  обработку  компоновщику  LD,  чтобы получить исполняемый файл lab4 (рис. 4.13). 

![Screenshot_329](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/57d35d3b-2d10-4de7-afff-4d2f17962a8d)


Рис. 4.13 Передача объектного файла на обработку компоновщику 

Запускаю исполняемый файл lab4, на экран действительно выводятся мои имя и фамилия (рис. 4.14). 

![Screenshot_330](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/e3bac40b-9a49-41a8-ba78-57f0eab6643f)


Рис. 4.14 Запуск исполняемого файла 

Удаляю лишние файлы в текущем каталоге с помощью утилиты rm (рис. 4.15). 

![Screenshot_331](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/8e40db0d-4d1b-4cb2-a856-074419b3d893)


Рис. 4.15 Удаление лишних файлов в текущем каталоге 

С  помощью  команд  git  add  .  и  git  commit  добавляю  файлы  на  GitHub, комментируя действие как добавление файлов для лабораторной работы №4 (рис. 4.16). 

![Screenshot_332](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/388402b0-7a7b-475e-a442-08ac40567738)


Рис. 4.16 Добавление файлов на GitHub 

Отправляю файлы на сервер с помощью команды git push (рис. 4.17). 

![Screenshot_333](https://github.com/evatsoppa/study_2023-2024_arh-pc/assets/145338773/ecdf8959-1b4e-4d67-8c44-9610126ed6ce)



Рис. 4.17 Отправка файлов 

**5 Выводы** 

При выполнении данной лабораторной работы я освоила процедуры компиляции и сборки программ, написанных на ассемблере NASM.

**6 Список литературы** 

1 https://esystem.rudn.ru/pluginfile.php/2089084/mod_resource/content/0/Лабораторная%20работа%20№4.%20Создание%20и%20процесс%20обработки%20программ%20на%20языке%20ассемблера%20NASM.pdf
14 
